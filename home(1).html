<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>DailyDish</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 0;
      background-color: #f8f9fa;
    }
    
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 2rem;
      background-color: #fff;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      position: sticky;
      top: 0;
      z-index: 100;
    }
    
    .logo {
      height: 50px;
    }
    
    .title {
      font-size: 1.8rem;
      font-weight: 700;
      color: #2c3e50;
      margin: 0;
    }
    
    .controls {
      display: flex;
      gap: 1rem;
      padding: 1.5rem;
      background-color: #fff;
      margin-bottom: 1rem;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.05);
    }
    
    .search-input {
      flex: 1;
      padding: 0.75rem;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 1rem;
    }
    
    .filter-select {
      padding: 0.75rem;
      border: 1px solid #ddd;
      border-radius: 6px;
      background-color: white;
      font-size: 1rem;
    }
    
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 1.5rem;
      padding: 1rem;
    }
    
    .card {
      background-color: white;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      transition: transform 0.3s ease;
      cursor: pointer;
    }
    
    .card:hover {
      transform: translateY(-5px);
    }
    
    .card-image {
      width: 100%;
      height: 200px;
      object-fit: cover;
    }
    
    .card-content {
      padding: 1.25rem;
    }
    
    .card-title {
      font-size: 1.25rem;
      margin: 0 0 0.5rem;
      color: #2c3e50;
    }
    
    .card-meta {
      display: flex;
      gap: 0.75rem;
      margin-bottom: 1rem;
      font-size: 0.9rem;
      color: #7f8c8d;
    }
    
    .badge {
      display: inline-block;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.75rem;
      font-weight: 600;
      margin-right: 0.5rem;
    }
    
    .veg { background-color: #27ae60; color: white; }
    .non-veg { background-color: #e74c3c; color: white; }
    .gluten-free { background-color: #f39c12; color: white; }
    .dairy-free { background-color: #8e44ad; color: white; }
    
    .card-details {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease;
      padding: 0 1.25rem;
    }
    
    .card.active .card-details {
      max-height: 1000px;
      padding: 0 1.25rem 1.25rem;
    }
    
    .detail-section {
      margin-bottom: 1rem;
    }
    
    .detail-title {
      font-size: 1rem;
      font-weight: 600;
      margin: 0 0 0.5rem;
      color: #34495e;
      border-bottom: 1px solid #ecf0f1;
      padding-bottom: 0.25rem;
    }
    
    .ingredients-list, .instructions-list {
      padding-left: 1.25rem;
      margin: 0.5rem 0;
    }
    
    .ingredients-list li, .instructions-list li {
      margin-bottom: 0.25rem;
      font-size: 0.9rem;
      color: #34495e;
    }
    
    .save-options {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-top: 1rem;
    }
    
    .save-btn {
      padding: 0.5rem 0.75rem;
      font-size: 0.8rem;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    
    .save-btn:hover {
      opacity: 0.9;
    }
    
    .breakfast-btn { background-color: #f6e58d; color: #333; }
    .lunch-btn { background-color: #7ed6df; color: #333; }
    .dinner-btn { background-color: #686de0; color: white; }
    .snacks-btn { background-color: #ff7979; color: white; }
    .dessert-btn { background-color: #e056fd; color: white; }
    
    .saved-notice {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: #27ae60;
      color: white;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.75rem;
      font-weight: 600;
      display: none;
      z-index: 1;
    }
    
    .loading {
      text-align: center;
      padding: 2rem;
      font-size: 1.2rem;
      color: #7f8c8d;
    }
    
    .error {
      color: #e74c3c;
      text-align: center;
      padding: 2rem;
    }
    
    .tags-container {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }
    
    .tag {
      background-color: #e0e0e0;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.75rem;
    }
    
    .planner-btn-container {
      display: flex;
      justify-content: center;
      margin: 1rem 0;
    }
    
    .planner-btn {
      background-color: #2ecc71;
      color: white;
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: 6px;
      font-size: 1rem;
      cursor: pointer;
      transition: background-color 0.2s;
      text-decoration: none;
      display: inline-block;
    }
    
    .planner-btn:hover {
      background-color: #27ae60;
    }
  </style>
</head>
<body>
  <header class="header">
    <img src="https://cdn.vectorstock.com/i/500p/89/68/abstract-logo-of-a-cafe-or-restaurant-spoon-vector-17248968.jpg" alt="Logo" class="logo">
    <h1 class="title">DailyDish</h1>
    <div>
      <!-- Removed the fetch random meals button -->
    </div>
  </header>

  <div class="controls">
    <input id="searchInput" type="text" placeholder="Search recipes..." class="search-input">
    <select id="categoryFilter" class="filter-select">
      <option value="">All Categories</option>
      <!-- Categories will be populated by JavaScript -->
    </select>
    <select id="areaFilter" class="filter-select">
      <option value="">All Cuisines</option>
      <!-- Areas will be populated by JavaScript -->
    </select>
  </div>

  <div class="planner-btn-container">
    <a href="planner.html" class="planner-btn">Go to Meal Planner</a>
  </div>

  <div id="recipesContainer" class="grid"></div>
  <div id="loading" class="loading">Loading recipes...</div>
  <div id="error" class="error" style="display: none;"></div>

  <script>
    document.addEventListener('DOMContentLoaded', async () => {
      const recipesContainer = document.getElementById('recipesContainer');
      const loadingElement = document.getElementById('loading');
      const errorElement = document.getElementById('error');
      const searchInput = document.getElementById('searchInput');
      const categoryFilter = document.getElementById('categoryFilter');
      const areaFilter = document.getElementById('areaFilter');
      
      let meals = [];
      let categories = [];
      let areas = [];
      let isLoading = false;
      let hasMore = true;
      
      // Fetch initial data
      async function initializeApp() {
        try {
          loadingElement.style.display = 'block';
          
          // Fetch categories and areas first
          const [categoriesRes, areasRes] = await Promise.all([
            fetch('https://www.themealdb.com/api/json/v1/1/list.php?c=list'),
            fetch('https://www.themealdb.com/api/json/v1/1/list.php?a=list')
          ]);
          
          if (!categoriesRes.ok || !areasRes.ok) throw new Error('Failed to fetch filters');
          
          const categoriesData = await categoriesRes.json();
          const areasData = await areasRes.json();
          
          categories = categoriesData.meals || [];
          areas = areasData.meals || [];
          
          // Populate filter dropdowns
          populateFilter(categoryFilter, categories, 'strCategory');
          populateFilter(areaFilter, areas, 'strArea');
          
          // Then fetch initial meals
          await fetchMoreMeals();
          
          // Set up infinite scroll
          window.addEventListener('scroll', handleScroll);
        } catch (err) {
          console.error('Error:', err);
          errorElement.textContent = `Error: ${err.message}`;
          errorElement.style.display = 'block';
        } finally {
          loadingElement.style.display = 'none';
        }
      }
      
      // Handle scroll event for infinite loading
      function handleScroll() {
        if (isLoading || !hasMore) return;
        
        // Check if we're near the bottom of the page
        if (window.innerHeight + window.scrollY >= document.body.offsetHeight - 500) {
          fetchMoreMeals();
        }
      }
      
      // Populate filter dropdown
      function populateFilter(selectElement, items, propertyName) {
        selectElement.innerHTML = `<option value="">All ${selectElement.id.replace('Filter', '')}</option>`;
        items.forEach(item => {
          const option = document.createElement('option');
          option.value = item[propertyName];
          option.textContent = item[propertyName];
          selectElement.appendChild(option);
        });
      }
      
      // Fetch more meals from TheMealDB API
      async function fetchMoreMeals() {
        if (isLoading) return;
        
        try {
          isLoading = true;
          loadingElement.style.display = 'block';
          errorElement.style.display = 'none';
          
          // Fetch 6 random meals at a time
          const mealPromises = Array.from({ length: 6 }, () => 
            fetch('https://www.themealdb.com/api/json/v1/1/random.php')
              .then(res => res.json())
              .then(data => data.meals[0])
          );
          
          const newMeals = await Promise.all(mealPromises);
          meals = [...meals, ...newMeals];
          renderMeals(meals);
          
          // In a real app, you might want to implement a way to know when there are no more meals
          // For this demo, we'll assume there's always more
          hasMore = true;
        } catch (err) {
          console.error('Error:', err);
          errorElement.textContent = `Error: ${err.message}`;
          errorElement.style.display = 'block';
        } finally {
          isLoading = false;
          loadingElement.style.display = 'none';
        }
      }
      
      // Extract ingredients and measurements from meal object
      function getIngredients(meal) {
        const ingredients = [];
        for (let i = 1; i <= 20; i++) {
          const ingredient = meal[`strIngredient${i}`];
          const measure = meal[`strMeasure${i}`];
          if (ingredient && ingredient.trim() !== '') {
            ingredients.push(`${measure ? measure.trim() + ' ' : ''}${ingredient.trim()}`);
          }
        }
        return ingredients;
      }
      
      // Format instructions into steps
      function formatInstructions(instructions) {
        if (!instructions) return [];
        // Split by new lines or numbers followed by periods
        return instructions.split('\r\n').filter(step => step.trim() !== '');
      }
      
      // Render meals to the DOM
      function renderMeals(mealsToRender) {
        // Don't clear the container, we're appending
        if (mealsToRender.length === 0) {
          recipesContainer.innerHTML = '<p style="grid-column:1/-1;text-align:center;">No meals found</p>';
          return;
        }
        
        // Only render new meals to avoid duplicates
        const startIndex = recipesContainer.children.length;
        
        for (let i = startIndex; i < mealsToRender.length; i++) {
          const meal = mealsToRender[i];
          const card = document.createElement('div');
          card.className = 'card';
          
          const ingredients = getIngredients(meal);
          const instructions = formatInstructions(meal.strInstructions);
          
          card.innerHTML = `
            <div class="saved-notice">Saved</div>
            <img src="${meal.strMealThumb}" alt="${meal.strMeal}" class="card-image">
            <div class="card-content">
              <h3 class="card-title">${meal.strMeal}</h3>
              <div class="card-meta">
                <span>${meal.strCategory}</span>
                <span>${meal.strArea}</span>
              </div>
              <div class="tags-container">
                ${meal.strTags ? meal.strTags.split(',').map(tag => 
                  `<span class="tag">${tag.trim()}</span>`
                ).join('') : ''}
              </div>
            </div>
            <div class="card-details">
              <div class="detail-section">
                <h4 class="detail-title">Ingredients</h4>
                <ul class="ingredients-list">
                  ${ingredients.map(ing => `<li>${ing}</li>`).join('')}
                </ul>
              </div>
              <div class="detail-section">
                <h4 class="detail-title">Instructions</h4>
                <ol class="instructions-list">
                  ${instructions.map((step, i) => `<li>${step}</li>`).join('')}
                </ol>
              </div>
              <div class="detail-section">
                <h4 class="detail-title">Video</h4>
                <p><a href="${meal.strYoutube}" target="_blank">Watch on YouTube</a></p>
              </div>
              <div class="save-options">
                <button class="save-btn breakfast-btn" data-id="${meal.idMeal}" data-type="breakfast">Breakfast</button>
                <button class="save-btn lunch-btn" data-id="${meal.idMeal}" data-type="lunch">Lunch</button>
                <button class="save-btn dinner-btn" data-id="${meal.idMeal}" data-type="dinner">Dinner</button>
                <button class="save-btn snacks-btn" data-id="${meal.idMeal}" data-type="snack">Snack</button>
                <button class="save-btn dessert-btn" data-id="${meal.idMeal}" data-type="dessert">Dessert</button>
              </div>
            </div>
          `;
          
          // Toggle details on click
          card.addEventListener('click', function(e) {
            if (!e.target.classList.contains('save-btn')) {
              this.classList.toggle('active');
            }
          });
          
          // Add save button handlers
          card.querySelectorAll('.save-btn').forEach(btn => {
            btn.addEventListener('click', async function(e) {
              e.stopPropagation();
              const mealId = this.getAttribute('data-id');
              const mealType = this.getAttribute('data-type');
              const mealName = meal.strMeal;
              
              try {
                // Load existing saved meals
                let savedMeals = JSON.parse(localStorage.getItem('savedMeals')) || {
                  breakfast: [],
                  lunch: [],
                  dinner: [],
                  snacks: [],
                  dessert: []
                };
                
                // Add the new meal
                savedMeals[mealType].push({
                  id: mealId,
                  name: mealName,
                  image: meal.strMealThumb,
                  category: meal.strCategory
                });
                
                // Save back to localStorage
                localStorage.setItem('savedMeals', JSON.stringify(savedMeals));
                
                // Visual feedback
                const originalText = this.textContent;
                this.textContent = '✓ Saved!';
                
                // Show saved notice
                const notice = this.closest('.card').querySelector('.saved-notice');
                notice.style.display = 'block';
                
                setTimeout(() => {
                  this.textContent = originalText;
                }, 2000);
              } catch (err) {
                alert('Failed to save meal: ' + err.message);
              }
            });
          });
          
          recipesContainer.appendChild(card);
        }
      }
      
      // Filter meals based on search and filters
      function filterMeals() {
        const searchText = searchInput.value.toLowerCase();
        const category = categoryFilter.value;
        const area = areaFilter.value;
        
        const filtered = meals.filter(meal => {
          const matchesText = meal.strMeal.toLowerCase().includes(searchText);
          const matchesCategory = !category || meal.strCategory === category;
          const matchesArea = !area || meal.strArea === area;
          
          return matchesText && matchesCategory && matchesArea;
        });
        
        // When filtering, we need to re-render all meals
        recipesContainer.innerHTML = '';
        renderMeals(filtered);
      }
      
      // Event listeners
      searchInput.addEventListener('input', filterMeals);
      categoryFilter.addEventListener('change', filterMeals);
      areaFilter.addEventListener('change', filterMeals);
      
      // Initial load
      initializeApp();
    });
  </script>
</body>
</html>
